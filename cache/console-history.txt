.exit
EOF
  });
    console.log("paused:", await ps.paused());
    await tx.wait();
    console.log("setPaused(false) tx:", tx.hash);
    const tx = await ps.connect(o).setPaused(false);
      throw new Error("Signer not owner");
    if ((await ps.owner()).toLowerCase() !== o.address.toLowerCase())
    const [o] = await hre.ethers.getSigners();
    const ps = await hre.ethers.getContractAt("EXWIFEPresale", addr(a));
  .setAction(async (a, hre) => {
  .addOptionalParam("address", "Presale address")
task("presale:unpause", "Unpause the presale")
  });
    console.log("paused:", await ps.paused());
    await tx.wait();
    console.log("setPaused(true) tx:", tx.hash);
    const tx = await ps.connect(o).setPaused(true);
      throw new Error("Signer not owner");
    if ((await ps.owner()).toLowerCase() !== o.address.toLowerCase())
    const [o] = await hre.ethers.getSigners();
    const ps = await hre.ethers.getContractAt("EXWIFEPresale", addr(a));
  .setAction(async (a, hre) => {
  .addOptionalParam("address", "Presale address")
task("presale:pause", "Pause the presale")
}
  );
    })()
      throw new Error("Set --address or PRESALE_ADDRESS");
    (() => {
    process.env.PRESALE_ADDRESS ||
    a.address ||
  return (
function addr(a) {
const { task } = require("hardhat/config");
cat > tasks/presale.js <<'EOF'
await ps.treasury();                            // treasury address
ethers.formatEther(await ps.minBuyWei());      // min buy in ETH
ethers.formatEther(await ps.priceWeiPerToken())// price in ETH per token (wei -> ETH)
(await ps.totalSoldTokens()).toString();       // tokens sold (raw units)
ethers.formatEther(await ps.totalRaisedWei()); // ETH raised (from contract accounting)
// other useful reads
await ps.paused();          // -> true/false
// confirm
await ps.setPaused(false);  // unpause (enable buys)
await ps.setPaused(true);   // pause (disable buys)
// toggle paused state
  .map(f => f.format())
  .filter(f => f.type === "function")
ps.interface.fragments
await ps.paused();   // true/false
await ps.unpause();  // enable buys
await ps.pause();    // disable buys
// already attached as `ps`
(await ethers.provider.getNetwork()).name
console.log("owner():", await ps.owner());
console.log("Signer:", signer.address);
const [signer] = await ethers.getSigners();
const ps = await ethers.getContractAt("EXWIFEPresale", PRESALE);
const PRESALE = "0xDe43eA415C91e2789Ac15Cf802487588218A4674";
.exit
})()
  return "✓ Airdrop test complete";
  console.log(`${sym} after:`, ethers.formatUnits(bAfter, dec));
  const bAfter = await erc.balanceOf(RECIPIENT);
  // Show balances after
  console.log("Airdrop tx:", tx.hash);
  await tx.wait();
  const tx = await ps.connect(owner).airdrop(RECIPIENT, toUnits(AMOUNT));
  if (typeof ps.airdrop !== "function") throw new Error("No airdrop() on presale.");
  // Airdrop
  console.log(`${sym} before:`, ethers.formatUnits(bBefore, dec));
  const bBefore = await erc.balanceOf(RECIPIENT);
  // Show balances before
  const toUnits = (n)=>ethers.parseUnits(n, dec);
  const dec = await erc.decimals().catch(()=>18);
  const sym = await erc.symbol().catch(()=>"TOKEN");
  }
    if (!f) throw new Error("Finalize first; airdrop is blocked until finalized.");
    const f = await ps.finalized();
  if (typeof ps.finalized === "function") {
  // Guard: finalized first (if view exists)
  if (onChainOwner !== owner.address.toLowerCase()) throw new Error("This signer is not the owner.");
  const onChainOwner = (await ps.owner()).toLowerCase();
  // Guard: signer must be owner
  const [owner] = await ethers.getSigners();
  const erc  = await ethers.getContractAt(ERC20_ABI, TOKEN);
  const ps   = await ethers.getContractAt("EXWIFEPresale", PRESALE);
  ];
    "function balanceOf(address) view returns (uint256)"
    "function symbol() view returns (string)",
    "function decimals() view returns (uint8)",
  const ERC20_ABI = [
  // Minimal ABIs
  const AMOUNT = "100"; // tokens (human units)
  const RECIPIENT = "0x2C35B446576cF2344288ea5aa654E990a4A4429c"; // your test wallet
  const TOKEN   = "0x0cF3EcA1AA8f4BCc10D51C8f4e75C17667D8Af07"; // EXWIFE (Sepolia)
  const PRESALE = "0xDe43eA415C91e2789Ac15Cf802487588218A4674";
;(async () => {
// === EXWIFE — minimal airdrop test (single paste) ===
console.log("Contract balance (ETH):", ethers.formatEther(await ethers.provider.getBalance(ps.target)));
const ps = await ethers.getContractAt("EXWIFEPresale", PRESALE);
const PRESALE = "0xDe43eA415C91e2789Ac15Cf802487588218A4674";
// Check contract balance post-finalize
})()
  console.log("✓ Finalize done");
  try { console.log("finalized():", await ps.finalized()); } catch {}
  console.log("Finalize tx:", tx.hash);
  const r = await tx.wait();
  catch { tx = await ps.connect(owner).finalize(); }
  try { tx = await ps.connect(owner).finalize(true); }
  let tx;
  // Try finalize with arg, then without
  if (now <= closingTime) throw new Error("Presale not closed yet; finalize only allowed after closingTime.");
  const now = Math.floor(Date.now()/1000);
  const closingTime = Number(await ps.closingTime());
  if (onChainOwner !== owner.address.toLowerCase()) throw new Error("This signer is not the contract owner.");
  const onChainOwner = (await ps.owner()).toLowerCase();
  // Sanity: owner & timing
  const [owner] = await ethers.getSigners();
  const ps = await ethers.getContractAt("EXWIFEPresale", PRESALE);
  const PRESALE = "0xDe43eA415C91e2789Ac15Cf802487588218A4674";
;(async () => {
// === Minimal finalize (no extras) ===
} ca
  console.log("Airdropped 100 tokens to:", recipient, "tx:", dropTx.hash);
  await dropTx.wait();
  const dropTx = await presale.connect(owner).airdrop(recipient, ethers.parseUnits("100", 18));
try {
const recipient = "0x2C35B446576cF2344288ea5aa654E990a4A4429c";
// change recipient if you want
/* ---------- Airdrop (optional test) ---------- */
console.log("Balance FINAL (ETH):", ethers.formatEther(balFinal));
let balFinal = await ethers.provider.getBalance(PRESALE);
// show final balance
await tryCall("withdraw()", () => presale.connect(owner).withdraw?.());
await tryCall("sweepETH()", () => presale.connect(owner).sweepETH?.());
await tryCall("sweep()", () => presale.connect(owner).sweep());
// Try a few common sweep function names; only one should exist on your contract
}
  }
    return false;
    console.log(label, "not available:", e?.error?.message || e?.message || e);
  } catch (e) {
    return true;
    console.log(label, "OK:", tx.hash);
    const r  = await tx.wait();
    const tx = await call();
  try {
async function tryCall(label, call) {
/* ---------- Sweep (optional, only if your contract requires manual sweep) ---------- */
console.log("Balance AFTER finalize (ETH):", ethers.formatEther(balAfterFinalize));
let balAfterFinalize = await ethers.provider.getBalance(PRESALE);
// show balance after finalize (in case sweep happened automatically)
} catch { console.log("no finalized() view; skipping"); }
  console.log("finalized():", await presale.finalized());
try {
// check finalized status
console.log("Finalize tx mined:", finalizeTx.hash);
await finalizeTx.wait();
}
  }
    throw e2;
    console.log("Error:", e2?.error?.message || e2?.message || e2);
    console.log("finalize() also failed.");
  } catch (e2) {
    finalizeTx = await presale.connect(owner).finalize();
  try {
  console.log("finalize(true) failed, trying finalize() without args…");
} catch (e1) {
  finalizeTx = await presale.connect(owner).finalize(true);
  console.log("Calling finalize(true)...");
try {
let finalizeTx;
/* ---------- Finalize ---------- */
console.log("Balance BEFORE (ETH):", ethers.formatEther(balBefore));
let balBefore = await ethers.provider.getBalance(PRESALE);
// show presale ETH balance before
console.log({ openingTime: open, closingTime: close, now, finalized: await presale.finalized?.() });
const now = Math.floor(Date.now()/1000);
const [open, close] = [Number(await presale.openingTime()), Number(await presale.closingTime())];
// show timing + finalized
}
  throw new Error("This signer is NOT the contract owner. Switch to owner wallet.");
if ((await presale.owner()).toLowerCase() !== owner.address.toLowerCase()) {
// sanity check you're the owner
console.log("Contract owner():", await presale.owner());
console.log("Signer:", owner.address);
const [owner] = await ethers.getSigners();
// owner signer from your hardhat config
const presale = await ethers.getContractAt("EXWIFEPresale", PRESALE);
const PRESALE = "0xDe43eA415C91e2789Ac15Cf802487588218A4674";
// ===== EXWIFE presale finalize flow (Hardhat console JS only) =====
</script>
}
  }
    console.warn('refreshRaised() failed:', e);
  } catch (e) {
    updateProgressUI(raisedEth);
    const raisedEth = Number(ethers.formatEther(balWei));
    const balWei    = await provider.getBalance(presaleAddr);
    if (!presaleAddr) return;
    const presaleAddr = window.PRESALE_ADDRESS || window.EXWIFE_ENV?.presale;
    const provider    = new ethers.BrowserProvider(window.ethereum || null);
  try {
async function refreshRaised() {
<script>
await rawCall("weiRaised");
await rawCall("wallet");
}
  }
    console.log(fnName, "REVERT:", e?.error?.message || e?.message || e);
  } catch (e) {
    console.log(fnName, "=", decoded.map(v => (v?.toString ? v.toString() : v)));
    const decoded = iface.decodeFunctionResult(fnName, r);
    }
      return;
      console.log(fnName, "REVERT (empty 0x)");
    if (r === "0x") {
    });
      from: "0x4799d7Bf70371A396E3415336DD821586A72D37e", // owner
      data,
      to: presale.target,
    const r = await ethers.provider.call({
  try {
  const data = iface.encodeFunctionData(fnName, []);
  const iface = presale.interface;
async function rawCall(fnName) {
// helper that does a low-level eth_call and decodes (so we see true revert vs value)
}
  console.log("weiRaised REVERT:", e?.error?.message || e?.message || e);
} catch (e) {
  if (r !== "0x") console.log("decoded weiRaised:", iface.decodeFunctionResult("weiRaised", r)[0].toString());
  console.log("weiRaised raw:", r);
  const r = await ethers.provider.call({ to: presale.target, data: dataR, from: "0x4799d7Bf70371A396E3415336DD821586A72D37e" });
try {
const dataR = iface.encodeFunctionData("weiRaised", []);
// ---- weiRaised() raw call
}
  console.log("wallet REVERT:", e?.error?.message || e?.message || e);
} catch (e) {
  if (r !== "0x") console.log("decoded wallet:", iface.decodeFunctionResult("wallet", r)[0]);
  console.log("wallet raw:", r);
  const r = await ethers.provider.call({ to: presale.target, data: dataW, from: "0x4799d7Bf70371A396E3415336DD821586A72D37e" });
try {
const dataW = iface.encodeFunctionData("wallet", []);
// ---- wallet() raw call
const iface = presale.interface;
// Use the contract's own interface for low-level calls
presale.target                                           // echo address
(await ethers.provider.getCode(presale.target)).length   // should be > 2 ("0x" means no code)
ethers.formatEther(await presale.connect(ownerVoid).weiRaised())
(await presale.connect(ownerVoid).weiRaised()).toString()
await presale.connect(ownerVoid).wallet()
// Now read owner-gated views through the owner
const ownerVoid = new ethers.VoidSigner(ownerAddr, ethers.provider);
// Create a VoidSigner so eth_call is sent "from" the owner
const ownerAddr = "0x4799d7Bf70371A396E3415336DD821586A72D37e";
// Use the owner address you already confirmed
await presale.finalized()   // if present; else it’ll throw
ethers.formatEther(await presale.weiRaised())
(await presale.weiRaised()).toString()
await presale.wallet()
Number(await presale.closingTime())
Number(await presale.openingTime())
await presale.paused()
await presale.owner()
// Direct reads (each should print a value)
try { await presale.token() } catch { "no token()" }
// 5) See if token() exists
try { (await presale.ethRaised()).toString() } catch { "no ethRaised()" }
try { (await presale.raised()).toString() } catch { "no raised()" }
try { (await presale.totalRaised()).toString() } catch { "no totalRaised()" }
try { (await presale.totalWeiRaised()).toString() } catch { "no totalWeiRaised()" }
try { (await presale.weiRaised()).toString() } catch { "no weiRaised()" }
// 4) Try likely weiRaised getters
try { await presale.vault() } catch { "no vault()" }
try { await presale.fundsWallet() } catch { "no fundsWallet()" }
try { await presale.beneficiary() } catch { "no beneficiary()" }
try { await presale.treasury() } catch { "no treasury()" }
try { await presale.wallet() } catch { "no wallet()" }
// 3) Try likely wallet/treasury getters
  .map(f => f.format())
  .filter(f => f.type === "function" && f.stateMutability === "view")
presale.interface.fragments
// 2) List all read-only functions so we see the exact names
const presale = await ethers.getContractAt("EXWIFEPresale", presaleAddr);
const presaleAddr = "0xDe43eA415C91e2789Ac15Cf802487588218A4674";
// 1) Re-attach using the real ABI from artifacts
try { (await presale.finalized()) } catch(e) { "no finalized() view" }
ethers.formatEther(await presale.weiRaised())
(await presale.wallet())
Number(await presale.closingTime())
Number(await presale.openingTime())
(await presale.paused())
(await presale.owner())
// 3) Read values
const presale = await ethers.getContractAt(ABI, presaleAddr);
const presaleAddr = "0xDe43eA415C91e2789Ac15Cf802487588218A4674";
// 2) Attach to presale
];
  "function finalized() view returns (bool)" // if your contract exposes this
  "function weiRaised() view returns (uint256)",
  "function wallet() view returns (address)",
  "function closingTime() view returns (uint256)",
  "function openingTime() view returns (uint256)",
  "function paused() view returns (bool)",
  "function owner() view returns (address)",
const ABI = [
// 1) Minimal ABI fragments (read-only)