<!doctype html>
<html lang="en">
<head>
<script>
// GATE4_HEAD_SHIM: defines window.updateNetworkPill early
(function(){
  if (typeof window === 'undefined') return;

  // Ensure env defaults
  window.EXWIFE_ENV = window.EXWIFE_ENV || {
    network: 'mainnet',
    presale: '0xF4A37B656A33d418FB37280c9304274078A9b3ed'
  };
  window.PRESALE_ADDRESS = window.EXWIFE_ENV.presale || window.PRESALE_ADDRESS;

  async function _updateNetworkPill(){
    const pillEl = document.getElementById('netPill');
    const buyBtn = document.getElementById('buyBtn');
    const scanLink = document.getElementById('scanLink');

    let pill = 'Ethereum', buyDisabled = false;
    try {
      if (window.ethereum?.request) {
        const idHex = await window.ethereum.request({ method: 'eth_chainId' }).catch(()=>null);
        const id = idHex ? parseInt(idHex, 16) : 1;
        if (id !== 1) { pill = 'Wrong Network'; buyDisabled = true; }
      } else {
        pill = 'No Wallet'; buyDisabled = false;
      }
    } catch (e) {
      pill = 'Error'; buyDisabled = true;
    }

    if (pillEl) pillEl.textContent = pill;
    if (buyBtn != null) buyBtn.disabled = buyDisabled;
    if (scanLink) scanLink.href = `https://etherscan.io/address/${window.PRESALE_ADDRESS}`;
    return { pill, buyDisabled, href: scanLink?.href || null };
  }

  // Only set if not already defined; otherwise keep existing
  if (typeof window.updateNetworkPill !== 'function') {
    window.updateNetworkPill = _updateNetworkPill;
  }

  // Auto-run once
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window.updateNetworkPill());
  } else {
    window.updateNetworkPill();
  }
})();

</script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EXWIFE — Presale (Mainnet)</title>

  <!-- Ethers UMD -->
<!-- Node 'process' shim for browser -->
<script>
  // Some UMD bundles check process.env
  window.global = window.global || window;
  window.process = window.process || { env: {} };
</script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.4/dist/ethers.umd.min.js"></script>

  <!-- ENV -->
  <script>
    window.EXWIFE_ENV = {
      network: 'mainnet',
      rpc: 'https://eth.drpc.org',
      presale: '0xF4A37B656A33d418FB37280c9304274078A9b3ed',
      token:   '0xd0F4f922891cBfaDB73511df7af66dE15DA93C94',
      symbol:  'EXWIFE',
      goalEth: 1200
    };
    window.GOAL_ETH = 1200;
    window.PRESALE_ADDRESS = window.EXWIFE_ENV.presale;
    window.PRESALE_ABI_MIN = [
      "function paused() view returns (bool)",
      "function totalRaisedWei() view returns (uint256)",
      "function weiRaised() view returns (uint256)",
      "function buy() payable"
    ];
  </script>

  <!-- Minimal styles -->
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto; background:#0e0f12; color:#e7e7ea; margin:0; }
    .pill { display:inline-block; background:#1c1d22; border:1px solid #2a2b31; padding:6px 10px; border-radius:999px; }
    .btn { background:#2d6cdf; border:none; color:#fff; padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer; }
    .wrap { max-width:680px; margin:40px auto; padding:0 16px; }
  </style>
  <!-- GATE10-FINGERPRINT: g10-verify-001 -->
<script id="walletconnect-loader">
(async () => {
  // Load Web3Modal + WalletConnect UMD bundles when needed
  function add(src){ return new Promise((res,rej)=>{ const s=document.createElement("script"); s.src=src; s.onload=res; s.onerror=rej; document.head.appendChild(s); }); }
  if (!window.ethereum) {
    await add("https://unpkg.com//ethereum-provider/dist/index.umd.js");
  }
})();
</script>
</head>
<!doctype html>
<html lang="en">
<head>
  <!-- EXWIFE v12.3 + UX POLISH v1: banner/countdown, progress numbers, toasts -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EXWIFE Presale (Mainnet) — v12.3</title>

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="/img/exwife-hero.png" />

  <!-- Ethers UMD (single include; no async/defer) -->
  

  <!-- ENV + minimal ABI -->
  

  <!-- Safe subscription shim: skip subscribing to missing events -->
  

  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu; background:#0e0f12; color:#e7e7ea; }
    .wrap { max-width:680px; margin:40px auto; padding:0 16px; }
    .card { background:#141417; border:1px solid #222; border-radius:14px; padding:18px; }
    .row { display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    .pill { background:#1c1d22; border:1px solid #2a2b31; padding:6px 10px; border-radius:999px; }
    .btn { background:#2d6cdf; border:none; color:#fff; padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .progress { width:100%; height:14px; background:#1a1b20; border:1px solid #2a2b31; border-radius:10px; overflow:hidden; margin-top:8px; }
    .bar { height:100%; width:2%; background:#22c55e; transition: width .6s ease; }
    code { background:#101115; border:1px solid #222; padding:2px 6px; border-radius:8px; }
    .muted { opacity:.85; }
    a { color:#9bbcff; text-decoration:none; }
    a:hover { text-decoration:underline; }
    input::placeholder { color:#9aa; }

    /* === UX POLISH v1: banner + progress numbers + toasts === */
    .banner {
      display:flex; gap:.5rem; align-items:center; justify-content:center;
      padding:.6rem .9rem; margin:12px auto 14px; max-width:980px;
      background:#111; color:#fff; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,.25);
      font-weight:600;
    }
    .banner .countdown { opacity:.9; font-weight:500; }

    .progress-wrap { max-width:900px; margin:10px auto 0; }
    .progress-head { display:flex; justify-content:space-between; margin-bottom:.35rem; font-weight:600; }
    .progress-outer {
      width:100%; height:14px; background:#1a1b20; border:1px solid #2a2b31; border-radius:999px; overflow:hidden;
      box-shadow:inset 0 1px 2px rgba(0,0,0,.08);
    }
    .progress-inner { height:100%; width:0%; background:linear-gradient(90deg, #5ac8fa, #34c759, #ffd60a); transition:width .35s ease-in-out; }

    .toast-stack { position:fixed; right:16px; bottom:16px; display:flex; flex-direction:column; gap:8px; z-index:9999; }
    .toast {
      min-width:260px; max-width:360px; padding:.75rem .9rem; border-radius:12px; color:#fff;
      background:#333; box-shadow:0 10px 24px rgba(0,0,0,.25); font-weight:600;
    }
    .toast.ok { background:#2e7d32; }
    .toast.err { background:#c62828; }
    .toast.info { background:#2c3e50; }
    .toast .sub { display:block; font-weight:500; opacity:.9; margin-top:.15rem; }
  </style>
<!-- === GATE5_SEO_BLOCK v1 === -->
<title>EXWIFE Token — Fair, Fun, and A Little Petty</title>
<meta name="description" content="EXWIFE (EXWIFE) — a cheeky, fair-launch presale on Ethereum. Buy in, watch the drama, and enjoy the ride.">

<link rel="canonical" href="https://exwifetoken.com/">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="theme-color" content="#0a0a0a">

<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://exwifetoken.com/">
<meta property="og:title" content="EXWIFE Token — Fair, Fun, and A Little Petty">
<meta property="og:description" content="EXWIFE (EXWIFE) — a cheeky, fair-launch presale on Ethereum.">
<meta property="og:image" content="https://exwifetoken.com/img/social-card.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">

<!-- Twitter -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="EXWIFE Token — Fair, Fun, and A Little Petty">
<meta name="twitter:description" content="EXWIFE (EXWIFE) — a cheeky, fair-launch presale on Ethereum.">
<meta name="twitter:image" content="https://exwifetoken.com/img/social-card.png">

<!-- Icons / PWA (keep your existing favicon.ico; these are additive) -->
<link rel="icon" type="image/png" sizes="32x32" href="/img/icon-32.png">
<link rel="icon" type="image/png" sizes="192x192" href="/img/icon-192.png">
<link rel="apple-touch-icon" sizes="180x180" href="/img/icon-180.png">
<link rel="manifest" href="/site.webmanifest">

<!-- Structured data (minimal) -->
<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@type":"WebSite",
  "name":"EXWIFE Token",
  "url":"https://exwifetoken.com/",
  "potentialAction":{
    "@type":"SearchAction",
    "target":"https://exwifetoken.com/?q={search_term_string}",
    "query-input":"required name=search_term_string"
  }
}
</script>
<!-- === /GATE5_SEO_BLOCK === -->

</head>
<body>

  <!-- Hero -->
  <header style="max-width:980px;margin:24px auto 6px;padding:0 12px;text-align:center">
    <img
      src="/img/exwife-hero.png"
      alt="EXWIFE Token"
      loading="lazy"
      style="max-width:100%;height:auto;border-radius:16px;display:inline-block;box-shadow:0 6px 24px rgba(0,0,0,.08)"
    />
    <h1 style="margin:14px 0 4px;font-size:28px;line-height:1.2;">EXWIFE Presale (Mainnet)</h1>
    <p style="margin:0;font-size:16px;opacity:.8">Goal: 1200 ETH • Safe, read-only UI until you connect</p>
  </header>

  <!-- Live banner + countdown -->
  <div id="presaleBanner" class="banner" role="status" aria-live="polite">
    <strong>Presale v3 live until Oct 12</strong>
    <span id="countdown" class="countdown">— calculating…</span>
  </div>

<h1 style="margin:0 0 6px;">EXWIFE Presale</h1>

    <div class="card">
      <div class="row">
        <div class="pill" id="status">Ready</div>
        <div class="pill" id="netPill" style="background:#3f3f46;border-color:#52525b">No Wallet</div>
        <div class="row" style="gap:8px;">
          <button class="btn" id="connectBtn" style="background:#475569">Connect</button>

          <div style="display:flex;gap:8px;align-items:center;background:#1c1d22;border:1px solid #2a2b31;border-radius:10px;padding:6px 8px;">
            <span style="opacity:.8">Amount</span>
            <input id="buyAmount" inputmode="decimal" placeholder="0.01" value="0.01"
                   style="width:90px;background:transparent;border:none;outline:none;color:#e7e7ea;font-weight:600;text-align:right" />
            <span style="opacity:.8">ETH</span>
          </div>

          <button class="btn" id="buyBtn">Buy 0.01 ETH</button>
          <button class="btn" id="refreshBtn" style="background:#374151">Refresh</button>
          <a id="txLink" class="pill" href="#" target="_blank" style="display:none;">View tx</a>
        </div>
      </div>

      <!-- Progress numbers + improved bar (keeps legacy IDs for compatibility) -->
      <div style="margin-top:14px;">
        <div class="progress-head">
          <span>Raised</span>
          <span id="progressNumbers">0.000 / 1200 ETH (0.00%)</span>
        </div>
        <div class="progress-outer" aria-label="Presale progress">
          <div id="progressBar" class="progress-inner" style="width:0%"></div>
        </div>

        <!-- legacy display retained so existing code still paints -->
        <div style="margin-top:10px">Raised: <strong id="raised">0.0000</strong> / <span id="goal-b">1200</span> ETH</div>
        <div class="progress"><div class="bar" id="bar"></div></div>
      </div>

      <div class="muted" style="margin-top:12px; word-break:break-all;">
        Presale: <code id="addr"></code>
        <div style="margin-top:6px;font-size:14px">
          <a id="scanLink" href="https://etherscan.io/address/0xF4A37B656A33d418FB37280c9304274078A9b3ed" target="_blank" rel="noopener">View on Etherscan</a>
          <button id="copyBtn" style="margin-left:8px;padding:4px 8px;border:1px solid #2a2b31;border-radius:8px;background:#1c1d22;color:#e7e7ea;cursor:pointer">Copy</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Toast container (notifications) -->
  <div id="toastStack" class="toast-stack" aria-live="polite" aria-atomic="true"></div>

  <!-- Core logic -->
  

    const signer  = await provider.getSigner();
    const addr    = window.PRESALE_ADDRESS;
    const abi     = window.PRESALE_ABI_MIN;
    const presale = new ethers.Contract(addr, abi, signer);

    // Amount + validation (tune as needed)
    const raw = (el('buyAmount')?.value || '').trim();
    const amt = Number(raw);
    const MIN = 0.001, MAX = 10;
    if (!isFinite(amt) || amt <= 0) { showToast('Enter an amount in ETH.', '', 'err'); setStatus('Ready'); return; }
    if (amt < MIN)                  { showToast(`Minimum is ${MIN} ETH`, '', 'err');  setStatus('Ready'); return; }
    if (amt > MAX)                  { showToast(`Maximum is ${MAX} ETH`, '', 'err');  setStatus('Ready'); return; }

    setStatus('Submitting tx…');
    showToast('Submitting transaction…', 'Confirm in your wallet', 'info', 3000);

    // Send tx
    const tx = await presale.buy({ value: ethers.parseEther(String(amt)) });

    // Explorer link depends on chain
    const link = el('txLink');
    const explorer = (chainIdStr === '11155111') ? 'https://sepolia.etherscan.io' : 'https://etherscan.io';
    if (link) { link.href = `${explorer}/tx/${tx.hash}`; link.style.display=''; }

    showToast('Buy submitted!', tx.hash.slice(0,10) + '…' + tx.hash.slice(-8), 'ok', 5200);
    await tx.wait();
    setStatus('✅ Confirmed');
    await window.EXWIFE_refreshRaised();

  } catch (e) {

<script id="wc-lazy-connect">
(() => {
  const $ = (s,r=document)=>r.querySelector(s);
  let connect = document.getElementById("connectBtn");
  if (!connect) {
    connect = document.createElement("button");
    connect.id = "connectBtn";
    connect.type = "button";
    connect.textContent = "Connect Wallet";
    connect.style.cssText = "display:inline-block;margin:0 0 10px 0;padding:8px 12px;border-radius:10px;border:1px solid #bbb;background:#f6f7f9;color:#111;font-size:14px";
    const buy = document.getElementById("buyBtn");
    const label = document.getElementById("amountLabel") || buy;
    buy && buy.parentNode.insertBefore(connect, label);
  }

  // Fallback banner shown only if no provider right now
  function ensureBanner(){
    let bar = document.getElementById("noWalletBar");
    if (window.ethereum) { if (bar) bar.remove(); return; }
    if (!bar) {
      bar = document.createElement("div");
      bar.id = "noWalletBar";
      bar.style.cssText = "margin:8px 0 12px 0;padding:10px;border:1px solid #e6b800;background:#fff8e1;border-radius:12px;color:#553;max-width:520px";
      bar.innerHTML = `
        No wallet detected. You can try WalletConnect or open in your wallet:
        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
          <a href="https://metamask.app.link/dapp/${location.host}" style="flex:1 0 auto;padding:8px 10px;border-radius:10px;background:#1f2937;color:#fff;text-decoration:none;text-align:center">Open in MetaMask</a>
          <a href="https://go.cb-w.com/dapp?cb_url=${encodeURIComponent(location.origin)}" style="flex:1 0 auto;padding:8px 10px;border-radius:10px;background:#0a84ff;color:#fff;text-decoration:none;text-align:center">Open in Coinbase Wallet</a>
        </div>`;
      connect.parentNode.insertBefore(bar, connect);
    }
  }
  ensureBanner();

  async function lazyLoadWC(){
    // only load when user taps Connect; never block the page
    function add(src){return new Promise((res,rej)=>{const s=document.createElement("script");s.src=src;s.async=true;s.onload=res;s.onerror=()=>rej(new Error("load fail: "+src));document.head.appendChild(s);});}
    if (!window.WalletConnectProvider?.EthereumProvider) {
      try { await add("https://unpkg.com//ethereum-provider/dist/index.umd.js"); }
      catch { await add("https://cdn.jsdelivr.net/npm//ethereum-provider/dist/index.umd.js"); }
    }
    if (!window.WalletConnectProvider?.EthereumProvider) throw new Error("WalletConnect script blocked");
  }

  connect.addEventListener("click", async () => {
    try {
      // If already have a provider (MM in-app), done
      if (window.ethereum) { ensureBanner(); (window.toast?.ok||console.log)("Wallet already available"); return; }
      await lazyLoadWC();
      const prov = await window.WalletConnectProvider.EthereumProvider.init({
        projectId: "",
        showQrModal: true,
        chains: [1],
        methods: ["eth_sendTransaction","eth_sign","personal_sign","eth_signTypedData","eth_requestAccounts","eth_accounts"],
        optionalMethods: ["wallet_switchEthereumChain","eth_chainId"]
      });
      await prov.enable(); // opens chooser/deep link
      window.ethereum = prov; // expose provider for the rest of the site
      ensureBanner();
      (window.toast?.ok||console.log)("Wallet connected via WalletConnect");
    } catch (e) {
      (window.toast?.err||console.error)("Connect failed: " + (e?.message || e));
      // Banner remains with deep links as fallback
    }
  }, { once:false });
})();
</script>

<!-- WC UMD (safe) -->
<script src="https://unpkg.com//modal.6.2/dist/index.umd.js"></script>
<script src="https://unpkg.com//ethereum-provider.11.2/dist/index.umd.js"></script>
<!-- /WC UMD -->

<!-- WC UMD (stable) -->
<script src="https://unpkg.com/@walletconnect/modal@2.6.2/dist/index.umd.js"></script>
<script src="https://unpkg.com/@walletconnect/ethereum-provider@2.11.2/dist/index.umd.js"></script>
<!-- /WC UMD -->

<!-- BEGIN GATE10_MOBILE_CONNECT_BUY -->
<script>
(() => {
  const PROJECT_ID = "3d93076061de5b64f55d16591d98dad5";
  const PRESALE = (window.PRESALE_ADDRESS || "0xF4A37B656A33d418FB37280c9304274078A9b3ed");
  const PRESALE_ABI_MIN = ["function buy() payable","function paused() view returns (bool)"];

  let _eip1193=null, _provider=null, _signer=null;
  const byId=(id)=>document.getElementById(id);
  const toast=(window.toast||{info:console.log, ok:console.log, err:console.error});
  const isIOS=()=>/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream;

  function ensureNoWalletBanner(){
    if (window.ethereum || document.querySelector("#noWalletBanner")) return;
    const host=location.host;
    const div=document.createElement("div");
    div.id="noWalletBanner";
    div.style.cssText="position:fixed;left:12px;right:12px;bottom:12px;background:#111;color:#fff;padding:12px;border-radius:14px;box-shadow:0 8px 26px rgba(0,0,0,.3);z-index:9999";
    div.innerHTML='<div style="font-weight:600;margin-bottom:6px">No wallet detected</div><div style="opacity:.9;margin-bottom:10px">Open in a mobile wallet:</div><div style="display:flex;gap:8px;flex-wrap:wrap"><a href="https://metamask.app.link/dapp/'+host+'" target="_blank" style="padding:8px 12px;background:#f6851b;color:#111;border-radius:10px;font-weight:600;text-decoration:none">Open in MetaMask</a><a href="https://go.cb-w.com/dapp?cb_url='+encodeURIComponent(location.href)+'" target="_blank" style="padding:8px 12px;background:#0052ff;color:#fff;border-radius:10px;font-weight:600;text-decoration:none">Open in Coinbase Wallet</a></div>';
    document.body.appendChild(div);
  }

  async function wcInit(chainId=1){
    const EthereumProvider=window.WalletConnectEthereumProvider?.default||window.WalletConnectEthereumProvider;
    if(!EthereumProvider) throw new Error("WalletConnect provider not loaded");
    return await EthereumProvider.init({
      projectId: PROJECT_ID, chains:[chainId], showQrModal:true,
      methods:["eth_sendTransaction","eth_sign","personal_sign","eth_signTypedData","eth_signTypedData_v4","wallet_switchEthereumChain","wallet_addEthereumChain"],
      optionalMethods:["eth_accounts","eth_requestAccounts"],
      events:["chainChanged","accountsChanged","disconnect"]
    });
  }

  async function connectWallet(){
    try{
      if(window.ethereum?.request){
        await window.ethereum.request({method:"eth_requestAccounts"});
        _eip1193=window.ethereum;
        _provider=new ethers.BrowserProvider(_eip1193);
        _signer=await _provider.getSigner();
        toast.ok("Wallet connected");
        return {type:"injected", provider:_provider};
      }
      const wc=await wcInit(1);
      await wc.enable();
      _eip1193=wc;
      _provider=new ethers.BrowserProvider(_eip1193);
      _signer=await _provider.getSigner();
      toast.ok("Wallet connected via WalletConnect");
      return {type:"walletconnect", provider:_provider};
    }catch(e){
      toast.err("Connect failed: "+(e?.message||e));
      if(isIOS()) ensureNoWalletBanner();
      throw e;
    }
  }

  async function handleBuyMobileSafe(){
    const amtEl=byId("amount")||byId("gate10Amt");
    const raw=amtEl?.value?.trim();
    if(!raw){ toast.err("Enter an amount in ETH."); return; }
    try{ if(!_signer) await connectWallet(); } catch { return; }

    try{
      const net=await _provider.getNetwork();
      if(Number(net.chainId)!==1){
        try{ await _eip1193.request({method:"wallet_switchEthereumChain", params:[{chainId:"0x1"}]}); }
        catch{ toast.err("Please switch to Ethereum Mainnet in your wallet."); return; }
      }
    }catch(e){ console.warn("Network check failed:", e); }

    try{
      const presale=new ethers.Contract(PRESALE,PRESALE_ABI_MIN,_signer);
      let paused=false; try{ paused=await presale.paused(); } catch{}
      if(paused){ toast.err("Presale is paused."); return; }
      const amtWei=ethers.parseEther(String(raw));
      toast.info("Submitting transaction… Confirm in your wallet");
      const tx=await presale.buy({ value: amtWei });
      const rc=await tx.wait();
      toast.ok("Success! Hash: "+(tx.hash||rc?.hash));
      if(typeof window.EXWIFE_refreshRaised==="function"){
        try{ await window.EXWIFE_refreshRaised(); } catch(e){ console.warn("refreshRaised failed:", e); }
      }
    }catch(e){
      toast.err("Buy error: "+(e?.shortMessage||e?.message||e));
      console.error(e);
    }
  }

  function wireUI(){
    const connectBtn=document.getElementById("connectBtn")||document.getElementById("gate10Connect")||document.querySelector("[data-connect]");
    const buyBtn=document.getElementById("buyBtn")||document.getElementById("gate10Buy")||document.querySelector("[data-buy]");
    if(connectBtn && !connectBtn.__wired){
      ["click","touchend"].forEach(evt=>connectBtn.addEventListener(evt,e=>{e.preventDefault();connectWallet();},{passive:true}));
      connectBtn.__wired=true;
    }
    if(buyBtn && !buyBtn.__wired){
      ["click","touchend"].forEach(evt=>buyBtn.addEventListener(evt,async e=>{e.preventDefault();await handleBuyMobileSafe();},{passive:true}));
      buyBtn.__wired=true;
    }
  }

  window.EXWIFE_connect=connectWallet;
  window.EXWIFE_buyInline=handleBuyMobileSafe;

  document.addEventListener("DOMContentLoaded", wireUI);
  setTimeout(wireUI, 500);
})();
</script>
<!-- END GATE10_MOBILE_CONNECT_BUY -->
<!-- UNIVERSAL CONNECT/BUY BINDER -->
<script>
(() => {
  // normalize text content for matching
  const norm = (el) => (el.textContent || "").replace(/\s+/g, " ").trim().toLowerCase();

  // is this element a button-ish control?
  const isButtonish = (el) => {
    if (!el) return false;
    const tag = (el.tagName || "").toLowerCase();
    const role = (el.getAttribute && (el.getAttribute("role")||"").toLowerCase()) || "";
    return tag === "button" || role === "button" || el.matches?.("a, [data-buy], [data-connect], [data-action]");
  };

  // try to wire a single element if its text matches
  function tryWire(el) {
    if (!isButtonish(el)) return false;
    const t = norm(el);
    // CONNECT matchers
    if (/(^|\s)(connect wallet|connect)(\s|$)/.test(t)) {
      if (!el.__exwife_connect) {
        el.addEventListener("click", (e) => { e.preventDefault?.(); window.EXWIFE_connect?.(); }, { passive: true });
        el.addEventListener("touchend", (e) => { e.preventDefault?.(); window.EXWIFE_connect?.(); }, { passive: true });
        el.__exwife_connect = true;
      }
      return true;
    }
    // BUY matchers
    if (/^buy(\s|$)/.test(t) || /(\s|^)buy now(\s|$)/.test(t)) {
      if (!el.__exwife_buy) {
        el.addEventListener("click", (e) => { e.preventDefault?.(); window.EXWIFE_buyInline?.(); }, { passive: true });
        el.addEventListener("touchend", (e) => { e.preventDefault?.(); window.EXWIFE_buyInline?.(); }, { passive: true });
        el.__exwife_buy = true;
      }
      return true;
    }
    return false;
  }

  // initial sweep
  function sweep() {
    document.querySelectorAll("button, a, [role='button'], [data-buy], [data-connect], [data-action]").forEach(tryWire);
  }

  // observe future DOM changes (e.g., React re-renders)
  const mo = new MutationObserver((muts) => {
    for (const m of muts) {
      m.addedNodes?.forEach((n) => {
        if (n.nodeType !== 1) return; // element
        if (tryWire(n)) return;
        n.querySelectorAll?.("button, a, [role='button'], [data-buy], [data-connect], [data-action]").forEach(tryWire);
      });
    }
  });

  // start once DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => { sweep(); mo.observe(document.body, { childList: true, subtree: true }); });
  } else {
    sweep();
    mo.observe(document.body, { childList: true, subtree: true });
  }

  // fallback: if no amount input exists, create a minimal hidden one so Buy has a value
  setTimeout(() => {
    const amt = document.getElementById("amount") || document.getElementById("gate10Amt");
    if (!amt) {
      const i = document.createElement("input");
      i.type = "text";
      i.id = "amount";
      i.inputMode = "decimal";
      i.placeholder = "0.001";
      i.value = "0.001";
      i.style.cssText = "position:fixed;left:-9999px;top:-9999px;opacity:0;"; // offscreen
      document.body.appendChild(i);
    }
  }, 500);
})();
</script>
<!-- /UNIVERSAL CONNECT/BUY BINDER -->
<!-- iOS Auto Deep-Link Patch -->
<script>
(() => {
  // Helper: detect iOS Safari (no injected wallet)
  const isIOS = () => /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

  // Carry amount in URL (?amt=0.001) and prefill on load inside wallet browser
  (function prefillAmountFromQuery(){
    try {
      const url = new URL(location.href);
      const qAmt = url.searchParams.get("amt");
      if (qAmt) {
        const i = document.getElementById("amount") || document.getElementById("gate10Amt");
        if (i && !i.value) i.value = qAmt;
      }
    } catch {}
  })();

  // Patch existing globals if present
  const _origConnect = window.EXWIFE_connect;
  const _origBuy     = window.EXWIFE_buyInline;

  // Pick your preferred wallet to deep-link by default
  const PREFERRED = "metamask"; // "metamask" | "coinbase"

  function deeplinkToWallet(withAmount) {
    const host = location.host;
    const u = new URL(location.href);
    if (withAmount) {
      const i = document.getElementById("amount") || document.getElementById("gate10Amt");
      if (i && i.value) u.searchParams.set("amt", String(i.value).trim());
    }
    const siteURL = u.toString();

    if (PREFERRED === "coinbase") {
      // Coinbase Wallet deep-link (cb_url is the dapp URL)
      const cb = "https://go.cb-w.com/dapp?cb_url=" + encodeURIComponent(siteURL);
      location.href = cb;
    } else {
      // MetaMask deep-link to your dapp
      const mm = "https://metamask.app.link/dapp/" + host + u.pathname + (u.search || "");
      location.href = mm;
    }
  }

  // Wrap connect: if on iOS without injected wallet, jump straight to wallet
  if (typeof _origConnect === "function") {
    window.EXWIFE_connect = async function() {
      if (isIOS() && !window.ethereum) {
        // Auto deep-link instead of showing banner/modals
        deeplinkToWallet(false);
        return;
      }
      return _origConnect.apply(this, arguments);
    };
  }

  // Wrap buy: if on iOS without injected wallet, deep-link and preserve amount
  if (typeof _origBuy === "function") {
    window.EXWIFE_buyInline = async function() {
      if (isIOS() && !window.ethereum) {
        deeplinkToWallet(true); // carry amount via ?amt=
        return;
      }
      return _origBuy.apply(this, arguments);
    };
  }
})();
</script>
<!-- EXWIFE: Buy/Connect hardening (amt clean + min guard + button lock) -->
<script>
(() => {
  const MIN_ETH = 0.001;

  // 1) Pre-fill amount from ?amt= and then clean it from the URL
  (function prefillAndCleanAmt(){
    try {
      const u = new URL(location.href);
      const qAmt = u.searchParams.get("amt");
      if (qAmt) {
        const i = document.getElementById("amount") || document.getElementById("gate10Amt");
        if (i && !i.value) i.value = qAmt;
        u.searchParams.delete("amt");
        history.replaceState({}, "", u.pathname + (u.search || "") + u.hash);
      }
    } catch(_) {}
  })();

  // helper: get buy button & amount input
  function getBuyBtn() {
    return document.getElementById("buyBtn")
        || document.getElementById("gate10Buy")
        || document.querySelector("[data-buy]")
        || document.querySelector("button, a, [role='button']");
  }
  function getAmtInput() {
    return document.getElementById("amount") || document.getElementById("gate10Amt");
  }

  // Compose wrappers around the original buy function
  function whenReady(fn) {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", fn, { once:true });
    } else {
      fn();
    }
  }

  whenReady(() => {
    // Wait until EXWIFE_buyInline exists; retry a few times if needed
    let tries = 0, maxTries = 10;
    const tick = setInterval(() => {
      const origBuy = window.EXWIFE_buyInline;
      if (typeof origBuy === "function" || ++tries >= maxTries) {
        clearInterval(tick);
        if (typeof origBuy !== "function") return; // nothing to wrap

        // (3) Min amount guard
        const withMinGuard = async function() {
          const i = getAmtInput();
          const v = i && parseFloat(i.value);
          if (!v || isNaN(v) || v < MIN_ETH) {
            (window.toast?.error || window.toast?.err || console.error)(`Min ${MIN_ETH} ETH`);
            return;
          }
          return await origBuy.apply(this, arguments);
        };

        // (2) Button lock (avoid double submits)
        const withLock = async function() {
          const btn = getBuyBtn();
          if (btn && btn.disabled) return;
          if (btn) { btn.disabled = true; btn.dataset.loading = "1"; }
          try {
            return await withMinGuard.apply(this, arguments);
          } finally {
            if (btn) { btn.disabled = false; delete btn.dataset.loading; }
          }
        };

        window.EXWIFE_buyInline = withLock;
      }
    }, 150);
  });
})();
</script>
<!-- /EXWIFE hardening -->
<!-- EXWIFE Runtime Scrubber: remove leaked inline code if present -->
<script>
(() => {
  const signatures = [
    "const signer = await provider.getSigner()",
    "const presale = new ethers.Contract",
    "buy() failed:",
    "EXWIFE v12.3 loaded",
    "Paused pill updater"
  ];

  function looksLikeLeak(el) {
    if (!el) return false;
    const t = (el.innerText || el.textContent || "").trim();
    if (t.length < 40) return false;
    return signatures.some(sig => t.includes(sig));
  }

  function scrub() {
    // Try common containers for debug/code leaks
    const candidates = Array.from(document.querySelectorAll(
      "pre, code, .footer, footer, .debug, #debug, .notes, .bottom, body > div:last-child, body > pre:last-child, body > code:last-child"
    ));
    // Also include any element at the bottom of the page
    const bodyChildren = Array.from(document.body.children);
    candidates.push(bodyChildren[bodyChildren.length-1]);

    let removed = 0;
    candidates.forEach(el => {
      if (!el) return;
      if (looksLikeLeak(el)) {
        el.style.display = "none"; // hide first (quick)
        el.remove?.();             // then remove if possible
        removed++;
      }
    });
    // As a final pass, search all <pre> everywhere (safeguard)
    document.querySelectorAll("pre, code").forEach(el => {
      if (looksLikeLeak(el)) { el.style.display = "none"; el.remove?.(); removed++; }
    });
    return removed;
  }

  // Run at DOM ready and again after a short delay (for late renders)
  const run = () => { scrub(); setTimeout(scrub, 600); setTimeout(scrub, 2000); };
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", run, { once: true });
  } else {
    run();
  }

  // Observe future DOM changes (e.g., React re-renders)
  const mo = new MutationObserver(() => scrub());
  mo.observe(document.documentElement, { childList: true, subtree: true });
})();
</script>
<!-- EXWIFE Runtime Scrubber v2: remove leaked inline code reliably -->
<script>
(() => {
  // Phrases that should never be visible on the page
  const SIGNATURES = [
    "const signer = await provider.getSigner()",
    "const presale = new ethers.Contract",
    "buy() failed:",
    "PRESALE_ABI_MIN",
    "updatePausedPill()",
    "EXWIFE v12.3 loaded"
  ];

  // If you want logs, flip to true in console: window.__EXWIFE_DEBUG_SCRUB = true
  const D = () => !!window.__EXWIFE_DEBUG_SCRUB;

  // Walk all text nodes and nuke containers that contain a signature
  function scrubTextNodes(root=document.body) {
    if (!root) return 0;
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
      acceptNode(node) {
        const t = (node.nodeValue || "").trim();
        if (t.length < 20) return NodeFilter.FILTER_SKIP;
        return SIGNATURES.some(sig => t.includes(sig))
          ? NodeFilter.FILTER_ACCEPT
          : NodeFilter.FILTER_SKIP;
      }
    });
    let removed = 0;
    const toRemove = new Set();

    while (walker.nextNode()) {
      const textNode = walker.currentNode;
      let el = textNode.parentElement;
      // climb up to a reasonably sized block (avoid removing the whole body)
      let hops = 0;
      while (el && el !== document.body && hops < 6) {
        const cs = getComputedStyle(el);
        const isBlocky = ["block","flex","grid","table","list-item"].includes(cs.display) || el.tagName.match(/^(DIV|SECTION|FOOTER|MAIN|ASIDE|P|PRE|CODE)$/);
        const bigEnough = (el.offsetWidth >= 200 || el.offsetHeight >= 30);
        if (isBlocky && bigEnough) break;
        el = el.parentElement; hops++;
      }
      if (el && el !== document.body) toRemove.add(el);
    }

    toRemove.forEach(el => {
      if (D()) console.warn("[EXWIFE scrub] removing leak container:", el);
      el.style.display = "none";
      el.remove?.();
      removed++;
    });
    return removed;
  }

  // One-shot scans + mutation observer to catch future injections
  function runScrub() {
    let n = 0;
    try { n += scrubTextNodes(); } catch {}
    // also try specific “last child” containers, common for footers
    try {
      const last = document.body && document.body.lastElementChild;
      if (last) n += scrubTextNodes(last);
    } catch {}

    if (D()) console.log("[EXWIFE scrub] pass removed =", n);
    return n;
  }

  // Initial passes
  const start = () => {
    runScrub();
    setTimeout(runScrub, 300);
    setTimeout(runScrub, 1500);
  };

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", start, { once: true });
  } else {
    start();
  }

  // Observe future DOM changes
  const mo = new MutationObserver(() => runScrub());
  mo.observe(document.documentElement, { childList: true, subtree: true });

  // Expose a manual re-scrub
  window.EXWIFE_scrubNow = runScrub;
})();
</script>
<!-- EXWIFE Runtime Scrubber v3: deep (DOM + shadow DOM) -->
<script>
(() => {
  // Flip on verbose logs with: window.__EXWIFE_DEBUG_SCRUB = true
  const DEBUG = () => !!window.__EXWIFE_DEBUG_SCRUB;

  // Phrases that should NEVER be visible
  const SIGS = [
    "const signer = await provider.getSigner()",
    "const presale = new ethers.Contract",
    "PRESALE_ABI_MIN",
    "buy() failed:",
    "setStatus('✅ Confirmed')",
    "EXWIFE v12.3 loaded"
  ];

  // Helper to iterate all nodes including shadow roots
  function* deepNodes(root) {
    const stack = [root];
    while (stack.length) {
      const n = stack.pop();
      yield n;
      // Shadow root
      if (n.shadowRoot) stack.push(n.shadowRoot);
      // Light DOM
      if (n.childNodes) {
        for (let i = n.childNodes.length - 1; i >= 0; i--) {
          stack.push(n.childNodes[i]);
        }
      }
      // If this is a DocumentFragment (e.g., shadowRoot), still iterate children via childNodes above
    }
  }

  function looksLikeLeakText(t) {
    if (!t) return false;
    const s = t.trim();
    if (s.length < 20) return false;
    return SIGS.some(sig => s.includes(sig));
  }

  // Find the nearest sensible container to remove
  function nearestContainer(el) {
    let hops = 0;
    while (el && el !== document.body && hops < 8) {
      const tag = el.tagName ? el.tagName.toLowerCase() : "";
      if (["pre","code","footer","div","section","aside","main","p"].includes(tag)) return el;
      el = el.parentElement || el.host || el.parentNode;
      hops++;
    }
    return null;
  }

  function scrubOnce(root = document.body) {
    if (!root) return 0;
    const toRemove = new Set();

    for (const n of deepNodes(root)) {
      // Text node?
      if (n.nodeType === 3) {
        if (looksLikeLeakText(n.nodeValue)) {
          let el = n.parentElement || (n.getRootNode && n.getRootNode().host) || null;
          const container = nearestContainer(el) || el;
          if (container && container !== document.body) toRemove.add(container);
        }
      }
      // Elements that might dump text
      else if (n.nodeType === 1) {
        const el = n;
        // Skip if not connected or hidden
        if (!el.isConnected) continue;
        const text = (el.innerText || el.textContent || "");
        if (looksLikeLeakText(text)) {
          const container = nearestContainer(el) || el;
          if (container && container !== document.body) toRemove.add(container);
        }
      }
    }

    let removed = 0;
    toRemove.forEach(el => {
      if (DEBUG()) console.warn("[EXWIFE scrub v3] removing leak container:", el);
      // Try to hide immediately, then remove
      el.style.display = "none";
      try { el.remove(); } catch {}
      removed++;
    });
    return removed;
  }

  // Run now, again soon, and on every repaint for a short time
  function runPasses() {
    let passes = 0;
    const maxPasses = 20; // ~2 seconds of rAF at 60fps
    function tick() {
      scrubOnce();
      if (++passes < maxPasses) requestAnimationFrame(tick);
    }
    scrubOnce();
    setTimeout(() => scrubOnce(), 300);
    setTimeout(() => scrubOnce(), 1500);
    requestAnimationFrame(tick);
  }

  // Observe DOM + shadow DOM changes
  let mo;
  function startObserver() {
    try {
      mo = new MutationObserver(() => scrubOnce());
      mo.observe(document.documentElement, { childList: true, subtree: true });
    } catch {}
  }

  // Public hook to re-scrub on demand
  window.EXWIFE_scrubNow = () => scrubOnce();

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => { runPasses(); startObserver(); }, { once:true });
  } else {
    runPasses(); startObserver();
  }
})();
</script>
</body></body>
</html>
<script id="gate10-selfheal-ui-js">
(()=>{try{
  const q=(s,r=document)=>r.querySelector(s);

  // Inject mobile CSS
  (function(){
    const css=[
      "@media (max-width:520px){",
      "#ex-dock{position:fixed;left:0;right:0;bottom:0;z-index:2147483646;",
      "padding:10px env(safe-area-inset-right) calc(10px + env(safe-area-inset-bottom)) env(safe-area-inset-left);",
      "background:rgba(18,18,22,.92);backdrop-filter:saturate(120%) blur(10px);",
      "box-shadow:0 -8px 24px rgba(0,0,0,.35)}",
      "#ex-dock .row{display:grid;grid-template-columns:1fr auto auto auto;gap:10px;align-items:center}",
      "#ex-dock input{min-height:44px;font-size:16px;padding:10px 12px;border-radius:12px;background:#0f172a;color:#e7e7ea;border:1px solid #1f2937;width:100%}",
      "#ex-dock button{min-height:44px;padding:12px 14px;border-radius:12px;background:#1f2937;color:#e7e7ea;border:1px solid #334155}",
      "#ex-dock #buyBtn{background:#2563eb;border-color:#1d4ed8;color:#fff}",
      "body{padding-bottom:96px}",
      "footer,.legal,.disclaimer,[data-footer],[data-legal]{max-height:32px;overflow:hidden;opacity:.7}",
      "}"
    ].join("");
    const s=document.createElement("style"); s.id="gate10-mobile-css"; s.textContent=css; document.head.appendChild(s);
  })();

  // Find/create amount input
  let amt=q("#amount")||q("#buyAmount")||q("input");
  const buy=q("#buyBtn")||Array.from(document.querySelectorAll("button")).find(b=>/buy/i.test(b.textContent||""));
  const max=q("#maxBtn")||null;
  const ref=q("#refreshBtn")||q("#refresh")||null;

  if(!amt){
    amt=document.createElement("input");
    amt.id="amount"; amt.type="text"; amt.autocapitalize="off"; amt.autocomplete="off";
  }
  amt.setAttribute("inputmode","decimal");
  amt.setAttribute("step","0.001");
  if(!amt.getAttribute("min")) amt.setAttribute("min","0.001");
  if(!amt.getAttribute("placeholder")) amt.setAttribute("placeholder","0.001 (min)");
  if(/^0?\.?0*1$/.test((amt.value||"").trim())) amt.value=""; // clear stray .01 default

  // Normalize Buy label & type
  if(buy){
    const t=(buy.textContent||"").trim();
    if(/buy/i.test(t) && /eth/i.test(t)) buy.textContent="Buy";
    if(!buy.type||buy.type.toLowerCase()!=="button") buy.type="button";
  }

  // Dock ORIGINAL nodes
  const isMobile=()=>matchMedia("(max-width:520px)").matches;
  const mountDock=()=>{
    if(!isMobile()||document.querySelector("#ex-dock")) return;
    const dock=document.createElement("div"); dock.id="ex-dock"; dock.innerHTML="<div class=\"row\"></div>";
    document.body.appendChild(dock);
    const row=dock.firstElementChild;
    if(!amt.isConnected) row.appendChild(amt);
    if(buy) row.appendChild(buy);
    if(max) row.appendChild(max);
    if(ref) row.appendChild(ref);
    const keep=()=>{ try{ dock.scrollIntoView({block:"end"});}catch(e){} };
    ["focus","click"].forEach(ev=> amt.addEventListener(ev, keep, {passive:true}));
  };
  mountDock();
  addEventListener("resize",()=>{ if(isMobile()&&!document.querySelector("#ex-dock")) mountDock(); });

  // Enable/disable & Enter-to-buy
  const MIN=0.001, valid=()=>{ const v=parseFloat((amt.value||"").trim()); return Number.isFinite(v)&&v>=MIN; };
  const sync=()=>{ try{ if(buy) buy.disabled=!valid(); }catch(e){} };
  amt.addEventListener("input",sync,{passive:true}); sync();
  const callBuy=(ev)=>{
    if(!valid()){ ev?.preventDefault?.(); return false; }
    try{ amt.blur?.(); }catch(e){}
    const fn=(window.handleBuy||window.EXWIFE_handleBuy||window.buyEXWIFE);
    if(typeof fn==="function") return fn.call(window, ev);
  };
  if(buy){
    buy.onclick=(ev)=>callBuy(ev);
    ["pointerup","touchend","click"].forEach(evt=> buy.addEventListener(evt,(ev)=>callBuy(ev),{capture:false,passive:false}));
  }
  amt.addEventListener("keydown",(e)=>{ if(e.key==="Enter"&&valid()){ e.preventDefault(); try{ buy?.click(); }catch(e){} } },{passive:false});
}catch(e){ console.warn("gate10-selfheal-ui (oneblock) failed:",e); }})();
</script>
